# import os
# import time
# from PyQt5.QtCore import QThread, pyqtSignal
import time

from PyQt5.QtWidgets import QApplication, QPushButton, QLabel, QVBoxLayout, QWidget
#
# class MyThread(QThread):
#     signal = pyqtSignal(str)
#
#     def __init__(self, function):
#         super().__init__()
#         self.function = function
#         self.flag = False
#
#     def run(self):
#         self.function()
#         self.signal.emit("Thread finished!")
#
#     def stop(self):
#         self.flag = True
#
# class MyWindow(QWidget):
#     def __init__(self):
#         super().__init__()
#         self.start_button = QPushButton("Start Thread")
#         self.stop_button = QPushButton("Stop Thread")
#         self.label = QLabel("")
#         self.thread = None
#
#         layout = QVBoxLayout()
#         layout.addWidget(self.start_button)
#         layout.addWidget(self.stop_button)
#         layout.addWidget(self.label)
#         self.setLayout(layout)
#
#         self.start_button.clicked.connect(self.start_thread)
#         self.stop_button.clicked.connect(self.stop_thread)
#         self.stop_button.setEnabled(False)
#
#     def start_thread(self):
#         self.thread = MyThread(lambda: self.heavy_task(arg1=1, arg2=2))
#         self.thread.signal.connect(self.update_label)
#         self.thread.start()
#         self.stop_button.setEnabled(True)
#         self.start_button.setEnabled(False)
#
#     def stop_thread(self):
#         self.thread.stop()
#         self.stop_button.setEnabled(False)
#         self.start_button.setEnabled(True)
#
#     def heavy_task(self, arg1, arg2):
#         while not self.thread.flag:
#             time.sleep(1)
#
#     def update_label(self, text):
#         self.label.setText(text)
#
#
#
# if __name__ == '__main__':
#     # app = QApplication([])
#     # window = MyWindow()
#     # window.show()
#     # app.exec_()
#     print(os.walk(r'D:\1').__next__()[1])
#     for i in os.walk(r'D:\1'):
#         print(i)
#         print(type(i))
#         print('————————————————————————')

# from paddleocr import PaddleOCR, draw_ocr
#
# # Paddleocr目前支持的多语言语种可以通过修改lang参数进行切换
# # 例如`ch`, `en`, `fr`, `german`, `korean`, `japan`
# ocr = PaddleOCR(use_angle_cls=True, lang="ch")  # need to run only once to download and load model into memory
# img_path = r'D:\2.jpg'
# result = ocr.ocr(img_path, cls=True)
# for line in result:
#     for box in line:
#         print(box[1][0])

# import os
# import cv2
# from paddleocr import PPStructure,draw_structure_result,save_structure_res
#
# table_engine = PPStructure(show_log=True)
#
# save_folder = r'D:\新建文件夹 (2)'
# img_path = r'D:\ManicTime_Screenshots\2023-02-01\2023-02-01_17-46-40_08-00_1920_1080_177951_0.jpg'
# img = cv2.imread(img_path)
# result = table_engine(img)
# save_structure_res(result, save_folder,os.path.basename(img_path).split('.')[0])
#
# for line in result:
#     line.pop('img')
#     print(line)
#
# from PIL import Image
#
# font_path = './fonts/simfang.ttf' # PaddleOCR下提供字体包
# image = Image.open(img_path).convert('RGB')
# im_show = draw_structure_result(image, result,font_path=font_path)
# im_show = Image.fromarray(im_show)
# im_show.save('result.jpg')

# a = {'type': 'figure', 'bbox': [0, 0, 1919, 1079], 'assets': [{'text': 'Clash for WindowS v 0.19.22 New', 'confidence': 0.9048664569854736, 'text_region': [[926.0, 151.0], [1331.0, 155.0], [1331.0, 189.0], [925.0, 184.0]]}, {'text': '<S-CΦ', 'confidence': 0.6118811964988708, 'text_region': [[106.0, 165.0], [262.0, 165.0], [262.0, 192.0], [106.0, 192.0]]}, {'text': '', 'confidence': 0.0, 'text_region': [[624.0, 167.0], [708.0, 167.0], [708.0, 188.0], [624.0, 188.0]]}, {'text': 'CSDn', 'confidence': 0.7940925359725952, 'text_region': [[164.0, 216.0], [274.0, 216.0], [274.0, 250.0], [164.0, 250.0]]}, {'text': 'Q html+css+js网..', 'confidence': 0.9201781153678894, 'text_region': [[298.0, 220.0], [520.0, 220.0], [520.0, 246.0], [298.0, 246.0]]}, {'text': 'Port', 'confidence': 0.9785085320472717, 'text_region': [[770.0, 232.0], [810.0, 232.0], [810.0, 254.0], [770.0, 254.0]]}, {'text': '李君丽老师', 'confidence': 0.9924495816230774, 'text_region': [[1145.0, 232.0], [1239.0, 232.0], [1239.0, 254.0], [1145.0, 254.0]]}, {'text': 'Allow LAN ^', 'confidence': 0.9423466324806213, 'text_region': [[770.0, 276.0], [892.0, 276.0], [892.0, 298.0], [770.0, 298.0]]}, {'text': '?', 'confidence': 0.4862295389175415, 'text_region': [[1151.0, 276.0], [1189.0, 276.0], [1189.0, 298.0], [1151.0, 298.0]]}, {'text': '1.因为现在智能图像识别还处于有监督识别', 'confidence': 0.8733965158462524, 'text_region': [[1201.0, 276.0], [1473.0, 276.0], [1473.0, 290.0], [1201.0, 290.0]]}, {'text': '阶段，还未到达无监督识别，也就是识别猫', 'confidence': 0.9453895092010498, 'text_region': [[1207.0, 294.0], [1475.0, 294.0], [1475.0, 313.0], [1207.0, 313.0]]}, {'text': 'tesseract安装及使用', 'confidence': 0.9250310063362122, 'text_region': [[118.0, 307.0], [480.0, 307.0], [480.0, 341.0], [118.0, 341.0]]}, {'text': '就只能识别猫，不能用猫的模型识别狗，所', 'confidence': 0.9717470407485962, 'text_region': [[1205.0, 309.0], [1477.0, 309.0], [1477.0, 335.0], [1205.0, 335.0]]}, {'text': '扫码体验更多内容', 'confidence': 0.997509241104126, 'text_region': [[594.0, 323.0], [716.0, 323.0], [716.0, 343.0], [594.0, 343.0]]}, {'text': 'Log Level', 'confidence': 0.8078888058662415, 'text_region': [[770.0, 321.0], [854.0, 321.0], [854.0, 341.0], [770.0, 341.0]]}, {'text': '以直接识别图片进行分类是不可行的。2.可', 'confidence': 0.9791933298110962, 'text_region': [[1207.0, 333.0], [1471.0, 333.0], [1471.0, 353.0], [1207.0, 353.0]]}, {'text': '以对图片的文字区域进行划分和识别，这个', 'confidence': 0.9374337196350098, 'text_region': [[1205.0, 349.0], [1473.0, 351.0], [1473.0, 373.0], [1205.0, 371.0]]}, {'text': 'IPv6', 'confidence': 0.978492259979248, 'text_region': [[770.0, 363.0], [810.0, 363.0], [810.0, 387.0], [770.0, 387.0]]}, {'text': '就是和高空抛物识别差不多，要能识别出图', 'confidence': 0.9534807801246643, 'text_region': [[1207.0, 373.0], [1475.0, 373.0], [1475.0, 393.0], [1207.0, 393.0]]}, {'text': 'showgea', 'confidence': 0.915468156337738, 'text_region': [[198.0, 389.0], [300.0, 389.0], [300.0, 411.0], [198.0, 411.0]]}, {'text': '关注', 'confidence': 0.9073543548583984, 'text_region': [[624.0, 389.0], [678.0, 389.0], [678.0, 419.0], [624.0, 419.0]]}, {'text': '片中的文字小区块，接着从小区块中识别文', 'confidence': 0.9063887596130371, 'text_region': [[1205.0, 393.0], [1475.0, 393.0], [1475.0, 413.0], [1205.0, 413.0]]}, {'text': 'Clash Core', 'confidence': 0.9368962049484253, 'text_region': [[770.0, 407.0], [864.0, 407.0], [864.0, 428.0], [770.0, 428.0]]}, {'text': '原创', 'confidence': 0.8199679255485535, 'text_region': [[198.0, 419.0], [246.0, 419.0], [246.0, 448.0], [198.0, 448.0]]}, {'text': 'Home Directory', 'confidence': 0.9560505747795105, 'text_region': [[770.0, 448.0], [908.0, 452.0], [907.0, 474.0], [769.0, 470.0]]}, {'text': '?', 'confidence': 0.5037674903869629, 'text_region': [[1151.0, 456.0], [1189.0, 456.0], [1189.0, 490.0], [1151.0, 490.0]]}, {'text': 'tesseract安装及使用', 'confidence': 0.9967207908630371, 'text_region': [[1208.0, 462.0], [1343.0, 464.0], [1343.0, 486.0], [1207.0, 484.0]]}, {'text': '153点赞·196159人阅读', 'confidence': 0.8902408480644226, 'text_region': [[114.0, 480.0], [346.0, 480.0], [346.0, 506.0], [114.0, 506.0]]}, {'text': 'UWPLoopback', 'confidence': 0.9612208008766174, 'text_region': [[772.0, 496.0], [902.0, 496.0], [902.0, 516.0], [772.0, 516.0]]}, {'text': '，安装tesserac', 'confidence': 0.8832504749298096, 'text_region': [[1217.0, 490.0], [1297.0, 490.0], [1297.0, 504.0], [1217.0, 504.0]]}, {'text': '每日', 'confidence': 0.9927282333374023, 'text_region': [[593.0, 500.0], [672.0, 511.0], [666.0, 549.0], [588.0, 538.0]]}, {'text': 'cSDn', 'confidence': 0.7173569798469543, 'text_region': [[1367.0, 510.0], [1403.0, 510.0], [1403.0, 524.0], [1367.0, 524.0]]}, {'text': 'OCR，即OpticalChara', 'confidence': 0.9317619204521179, 'text_region': [[1211.0, 524.0], [1343.0, 524.0], [1343.0, 538.0], [1211.0, 538.0]]}, {'text': '1.安装tesseract', 'confidence': 0.9578513503074646, 'text_region': [[116.0, 538.0], [262.0, 538.0], [262.0, 559.0], [116.0, 559.0]]}, {'text': 'TAPDevice', 'confidence': 0.9372784495353699, 'text_region': [[772.0, 535.0], [868.0, 540.0], [867.0, 560.0], [771.0, 555.0]]}, {'text': '鲨百度APP', 'confidence': 0.8741173148155212, 'text_region': [[1209.0, 551.0], [1283.0, 551.0], [1283.0, 573.0], [1209.0, 573.0]]}, {'text': 'Service Mode ', 'confidence': 0.9123221039772034, 'text_region': [[770.0, 583.0], [912.0, 583.0], [912.0, 603.0], [770.0, 603.0]]}, {'text': 'X', 'confidence': 0.8524803519248962, 'text_region': [[114.0, 593.0], [152.0, 593.0], [152.0, 629.0], [114.0, 629.0]]}, {'text': '登录之后浏览更方便哦～', 'confidence': 0.9595146775245667, 'text_region': [[244.0, 597.0], [568.0, 597.0], [568.0, 625.0], [244.0, 625.0]]}, {'text': '17:45', 'confidence': 0.9070131182670593, 'text_region': [[1377.0, 595.0], [1417.0, 595.0], [1417.0, 611.0], [1377.0, 611.0]]}, {'text': 'TUN Mode', 'confidence': 0.9344437718391418, 'text_region': [[772.0, 625.0], [916.0, 625.0], [916.0, 647.0], [772.0, 647.0]]}, {'text': '好心', 'confidence': 0.5922614336013794, 'text_region': [[1565.0, 629.0], [1643.0, 629.0], [1643.0, 657.0], [1565.0, 657.0]]}, {'text': 'Mixin o☆', 'confidence': 0.676971435546875, 'text_region': [[770.0, 666.0], [870.0, 666.0], [870.0, 688.0], [770.0, 688.0]]}, {'text': '?日甲', 'confidence': 0.3525039255619049, 'text_region': [[1147.0, 684.0], [1267.0, 684.0], [1267.0, 706.0], [1147.0, 706.0]]}, {'text': 'C口', 'confidence': 0.5176292061805725, 'text_region': [[1599.0, 684.0], [1649.0, 684.0], [1649.0, 706.0], [1599.0, 706.0]]}, {'text': 'System Proxy', 'confidence': 0.9502120614051819, 'text_region': [[770.0, 714.0], [884.0, 714.0], [884.0, 736.0], [770.0, 736.0]]}, {'text': '我现在调用了百度飞浆的ocr模块', 'confidence': 0.9225016832351685, 'text_region': [[1147.0, 716.0], [1353.0, 716.0], [1353.0, 736.0], [1147.0, 736.0]]}, {'text': '键登录', 'confidence': 0.993739128112793, 'text_region': [[372.0, 728.0], [470.0, 728.0], [470.0, 764.0], [372.0, 764.0]]}, {'text': '', 'confidence': 0.0, 'text_region': [[356.0, 738.0], [368.0, 738.0], [368.0, 748.0], [356.0, 748.0]]}, {'text': 'Start with Windows', 'confidence': 0.9723379611968994, 'text_region': [[768.0, 752.0], [940.0, 756.0], [939.0, 782.0], [767.0, 777.0]]}, {'text': '发送(S)', 'confidence': 0.9811536073684692, 'text_region': [[1569.0, 817.0], [1619.0, 817.0], [1619.0, 835.0], [1569.0, 835.0]]}, {'text': '登录代表你同意《用户服务条款》、', 'confidence': 0.9394324421882629, 'text_region': [[182.0, 837.0], [518.0, 837.0], [518.0, 863.0], [182.0, 863.0]]}, {'text': '《隐私政策》', 'confidence': 0.9921197891235352, 'text_region': [[514.0, 839.0], [622.0, 839.0], [622.0, 861.0], [514.0, 861.0]]}, {'text': 'A', 'confidence': 0.1746804267168045, 'text_region': [[678.0, 914.0], [722.0, 914.0], [722.0, 930.0], [678.0, 930.0]]}, {'text': 'CN。）管', 'confidence': 0.6847608685493469, 'text_region': [[1827.0, 944.0], [1909.0, 944.0], [1909.0, 964.0], [1827.0, 964.0]]}, {'text': '', 'confidence': 0.0, 'text_region': [[16.0, 1051.0], [34.0, 1051.0], [34.0, 1067.0], [16.0, 1067.0]]}, {'text': '+', 'confidence': 0.9198305606842041, 'text_region': [[216.0, 1053.0], [228.0, 1053.0], [228.0, 1063.0], [216.0, 1063.0]]}, {'text': 'PC', 'confidence': 0.8363900184631348, 'text_region': [[504.0, 1049.0], [526.0, 1049.0], [526.0, 1067.0], [504.0, 1067.0]]}, {'text': '山', 'confidence': 0.09007452428340912, 'text_region': [[798.0, 1047.0], [820.0, 1047.0], [820.0, 1067.0], [798.0, 1067.0]]}, {'text': '口', 'confidence': 0.3043777346611023, 'text_region': [[1661.0, 1049.0], [1723.0, 1049.0], [1723.0, 1069.0], [1661.0, 1069.0]]}, {'text': '巨', 'confidence': 0.10571596026420593, 'text_region': [[1877.0, 1051.0], [1895.0, 1051.0], [1895.0, 1067.0], [1877.0, 1067.0]]}], 'img_idx': 0}
#
# for i in range(0,200):
#     print(a['assets'][i]['text'])

# import pyautogui
# import pyperclip
# import time
# import datetime
#
#
# time.sleep(5110)
#
# text_to_copy = "啊啊啊啊啊啊啊啊啊啊啊啊啊祝你生日快乐!"
# pyperclip.copy(text_to_copy)
# pyautogui.hotkey('ctrl', 'v')
# pyautogui.press("enter")

# import sys
# import threading
# import time
# from PyQt5.QtCore import QObject, pyqtSignal
#
# class Functions(QObject):
#     data_generated = pyqtSignal(list)
#
#     def function1(self):
#         data = []
#         for i in range(5):
#             data.append(i)
#             time.sleep(1)
#             self.data_generated.emit(data)
#
#     def function2(self, data):
#         if data:
#             print("Function 2 processing:", data)
#
#     def function3(self, data):
#         if data:
#             print("Function 3 processing:", data)
#
# def main():
#     functions = Functions()
#     functions.data_generated.connect(functions.function2)
#     functions.data_generated.connect(functions.function3)
#
#     thread = threading.Thread(target=functions.function1)
#     thread.start()
#
# if __name__ == '__main__':
#     main()

# if __name__ == '__main__':
#     app = QApplication(sys.argv)
#     main_thread = MainThread()
#     main_thread.run()
#     sys.exit(app.exec_())

# import pygame
# import time
#
# def sushe():
#     pygame.init()
#     j = pygame.joystick.Joystick(0)
#     j.init()
#     # 按下b键
#     j.get_button ( 1 )
#     pygame.event.pump ()
#     time.sleep ( 0.005 )
#
#     # 放开b键
#     j.get_button ( 1 )
#     pygame.event.pump ()
#     time.sleep ( 0.005 )
#
#     # 按下lt键
#     j.get_axis ( 2 )
#     pygame.event.pump ()
#     time.sleep ( 0.005 )
#
#     # 放开lt键
#     j.get_axis ( 2 )
#     pygame.event.pump ()
#     time.sleep ( 0.005 )
#
#     # 按下lt键
#     j.get_axis ( 2 )
#     pygame.event.pump ()
#     time.sleep ( 0.005 )
#
#     # 放开lt键
#     j.get_axis ( 2 )
#     pygame.event.pump ()
#     time.sleep ( 0.005 )
#
# pygame.init()
# j = pygame.joystick.Joystick ( 0 )
# while True:
#     if j.get_button(1) == 1:
#         sushe()
#     # pygame.quit()



# import cv2
# import numpy as np
# import keyboard
#
# def play_video(path, frame_list):
#     cap = cv2.VideoCapture(path)
#     idx = 0
#     pause = False
#     while True:
#         if not pause:
#             ret, frame = cap.read()
#             if not ret:
#                 break
#             if idx < len(frame_list) and cap.get(1) >= frame_list[idx]:
#                 cap.set(1, frame_list[idx])
#                 idx += 1
#         cv2.imshow("video", frame)
#         if cv2.waitKey(25) & 0xFF == ord('q'):
#             break
#         if keyboard.is_pressed(" "):
#             pause = not pause
#         if keyboard.is_pressed("left"):
#             idx = max(0, idx-1)
#             cap.set(1, frame_list[idx])
#         if keyboard.is_pressed("right"):
#             idx = min(len(frame_list)-1, idx+1)
#             cap.set(1, frame_list[idx])
#     cap.release()
#     cv2.destroyAllWindows()
#
# path = "path/to/video.mp4"
# frame_list = [100, 200, 300, 400, 500]
# play_video(path, frame_list)

# from moviepy.video.io.VideoFileClip import VideoFileClip
# import cv2
#
# def play_video(path,frame_indices):
#
#
#     # Open the video file
#     video = VideoFileClip ( path )
#
#     # Get the total number of frames in the video
#     total_frames = int ( video.fps * video.duration )
#
#     # Specify the frame indices that you want to play
#
#
#     # Loop through the specified frames
#     for frame_index in frame_indices :
#         # Get the specified frame as a numpy array
#         frame = video.get_frame ( frame_index / video.fps )
#
#         # Display the frame
#         cv2.imshow ( "Frame", frame )
#
#         # Wait for the specified amount of time (in milliseconds)
#         cv2.waitKey ( 100 )
#
#     # Close all OpenCV windows
#     cv2.destroyAllWindows ()


# from moviepy.video.io.VideoFileClip import VideoFileClip
# import cv2
# import numpy as np
#
# def play_video(path,frame_indices):
#     # Open the video file
#     video = VideoFileClip(path)
#
#     # Get the total number of frames in the video
#     total_frames = int(video.fps * video.duration)
#
#     # Specify the frame indices that you want to play
#
#
#     # Loop through the specified frames
#     for frame_index in frame_indices:
#         # Get the specified frame as a numpy array
#         frame = video.get_frame(frame_index / video.fps)
#
#         # Convert the frame from RGB to BGR format
#         frame = frame[:, :, ::-1]
#
#         # Display the frame
#         cv2.imshow("Frame", frame)
#
#         # Wait for the specified amount of time (in milliseconds)
#         cv2.waitKey(100)
#
#     # Close all OpenCV windows
#     cv2.destroyAllWindows()


# import cv2
#
# def play_specific_frames(file_path, frame_numbers):
#     cap = cv2.VideoCapture(file_path)
#
#     while True:
#         ret, frame = cap.read()
#         if not ret:
#             break
#         if cap.get(cv2.CAP_PROP_POS_FRAMES) in frame_numbers:
#             cv2.imshow("frame", frame)
#             if cv2.waitKey(25) & 0xFF == ord('q'):
#                 break
#
#     cap.release()
#     cv2.destroyAllWindows()

# set = {(7626, '2023-01-26'), (13709, '2023-01-31'), (7531, '2023-01-26'), (7610, '2023-01-26'), (7214, '2023-01-26'), (19352, '2023-01-30'), (7630, '2023-01-26'), (7348, '2023-01-26'), (24476, '2023-01-30'), (18454, '2023-01-30'), (7535, '2023-01-26'), (16597, '2023-02-02'), (22807, '2023-01-30'), (7537, '2023-01-26'), (7548, '2023-01-26'), (7616, '2023-01-26'), (7627, '2023-01-26'), (7322, '2023-01-29'), (16599, '2023-02-02'), (7552, '2023-01-26'), (18321, '2023-01-30'), (3465, '2023-01-31'), (7550, '2023-01-26'), (19459, '2023-01-30'), (13543, '2023-01-31'), (19263, '2023-01-30'), (19353, '2023-01-30'), (7554, '2023-01-26'), (7644, '2023-01-26'), (7620, '2023-01-26'), (6198, '2023-01-26'), (15224, '2023-01-30'), (19331, '2023-01-30'), (7646, '2023-01-26'), (7633, '2023-01-26'), (7351, '2023-01-26'), (18457, '2023-01-30'), (16565, '2023-02-02'), (20457, '2023-01-30'), (23241, '2023-01-30'), (19348, '2023-01-30'), (7650, '2023-01-26'), (13623, '2023-01-31'), (19332, '2023-01-30'), (7533, '2023-01-26'), (7544, '2023-01-26'), (7623, '2023-01-26'), (23239, '2023-01-30'), (18313, '2023-01-30'), (16595, '2023-02-02'), (16606, '2023-02-02'), (22805, '2023-01-30'), (18317, '2023-01-30'), (14581, '2023-02-02'), (3472, '2023-01-31'), (7546, '2023-01-26'), (7647, '2023-01-26'), (7557, '2023-01-26'), (7636, '2023-01-26'), (18315, '2023-01-30'), (21429, '2023-01-30'), (7350, '2023-01-26'), (18460, '2023-01-30'), (13616, '2023-01-31'), (19349, '2023-01-30'), (24475, '2023-01-30'), (18319, '2023-01-30'), (3474, '2023-01-31'), (21431, '2023-01-30'), (19351, '2023-01-30'), (11950, '2023-01-27'), (7653, '2023-01-26'), (7642, '2023-01-26'), (7629, '2023-01-26'), (7347, '2023-01-26'), (7640, '2023-01-26'), (19428, '2023-01-30'), (19461, '2023-01-30'), (18453, '2023-01-30'), (13622, '2023-01-31'), (16561, '2023-02-02'), (7536, '2023-01-26'), (7615, '2023-01-26'), (16598, '2023-02-02'), (7540, '2023-01-26'), (7551, '2023-01-26'), (4013, '2023-02-02'), (16602, '2023-02-02'), (7538, '2023-01-26'), (3468, '2023-01-31'), (19330, '2023-01-30'), (7542, '2023-01-26'), (7553, '2023-01-26'), (7632, '2023-01-26'), (7643, '2023-01-26'), (16604, '2023-02-02'), (18456, '2023-01-30'), (19266, '2023-01-30'), (4010, '2023-02-02'), (16564, '2023-02-02'), (2125, '2023-01-28'), (3470, '2023-01-31'), (20459, '2023-01-30'), (7555, '2023-01-26'), (7621, '2023-01-26'), (19347, '2023-01-30'), (7649, '2023-01-26'), (7625, '2023-01-26'), (7213, '2023-01-26'), (14583, '2023-02-02'), (13706, '2023-01-31'), (7651, '2023-01-26'), (7638, '2023-01-26'), (13576, '2023-01-31'), (7532, '2023-01-26'), (7543, '2023-01-26'), (7215, '2023-01-26'), (7622, '2023-01-26'), (16605, '2023-02-02'), (7547, '2023-01-26'), (23242, '2023-01-30'), (14580, '2023-02-02'), (7534, '2023-01-26'), (14584, '2023-02-02'), (3464, '2023-01-31'), (7349, '2023-01-26'), (22806, '2023-01-30'), (7549, '2023-01-26'), (7639, '2023-01-26'), (19458, '2023-01-30'), (18318, '2023-01-30'), (13542, '2023-01-31'), (13577, '2023-01-31'), (21430, '2023-01-30'), (14586, '2023-02-02'), (3466, '2023-01-31'), (19350, '2023-01-30'), (7641, '2023-01-26'), (7628, '2023-01-26'), (7652, '2023-01-26'), (18320, '2023-01-30'), (19460, '2023-01-30'), (21434, '2023-01-30'), (16600, '2023-02-02'), (6199, '2023-01-26'), (21432, '2023-01-30'), (16560, '2023-02-02'), (16562, '2023-02-02'), (14579, '2023-02-02'), (7634, '2023-01-26'), (7352, '2023-01-26'), (7645, '2023-01-26'), (18458, '2023-01-30'), (7539, '2023-01-26'), (4012, '2023-02-02'), (16601, '2023-02-02'), (17028, '2023-02-02'), (23238, '2023-01-30'), (3467, '2023-01-31'), (20458, '2023-01-30'), (7541, '2023-01-26'), (7631, '2023-01-26'), (3471, '2023-01-31'), (16603, '2023-02-02'), (18455, '2023-01-30'), (19265, '2023-01-30'), (7545, '2023-01-26'), (7556, '2023-01-26'), (7635, '2023-01-26'), (23240, '2023-01-30'), (18314, '2023-01-30'), (2124, '2023-01-28'), (3469, '2023-01-31'), (18459, '2023-01-30'), (16563, '2023-02-02'), (7609, '2023-01-26'), (7637, '2023-01-26'), (7624, '2023-01-26'), (7648, '2023-01-26'), (18316, '2023-01-30'), (13696, '2023-01-31'), (13707, '2023-01-31'), (16596, '2023-02-02'), (14582, '2023-02-02')}
# for i in set:
#     if i[1] == '2023-01-26':
#         print(i[0],end=',')
# play_specific_frames(r"D:\ManicTime_Screenshots\2023-01-26_1920x1080.mp4",[7552,7550,7554,7620,7631,7635,7633,7637,7648,7650,7533,7544,7610,7214,7348,7546,7557,7350,7627,7616,7629,7640,7644,6198,7536,7646,7351,7540,7551,7542,7553,7623,7621,7647,7636,7625,7213,7638,7532,7543,7215,7653,7642,7347,7547,7349,7549,7615,7538,7628,7632,7643,7555,7634,7645,7539,7649,7541,7651,7545,7556,7622,7609,7534,7624,7639,7626,7531,7630,7641,7652,7535,6199,7537,7548,7352,
# ])


# import cv2
#
# # 读入视频
# video = cv2.VideoCapture ( r"D:\ManicTime_Screenshots\2023-01-25_1920x1080.mp4" )
#
# # 设置变量存储前一帧图像
# prev_frame = None
#
# while True :
#     # 读取当前帧
#     ret, frame = video.read ()
#
#     # 如果到达视频末尾，退出循环
#     if not ret :
#         break
#
#     # 如果前一帧图像不存在，将当前帧设置为前一帧
#     if prev_frame is None :
#         prev_frame = frame
#         continue
#
#     # 计算当前帧和前一帧的差分图像
#     diff = cv2.absdiff ( prev_frame, frame )
#
#     # 将当前帧设置为前一帧
#     prev_frame = frame
#
#     # 显示差分图像
#     cv2.imshow ( "diff", diff )
#
#     # 等待按键事件
#     key = cv2.waitKey ( 30 ) & 0xff
#     if key == 27 :  # 按下ESC键退出
#         break
#
#     # 将差分图像转换为二值图像，便于轮廓检测
#     diff = cv2.cvtColor ( diff, cv2.COLOR_BGR2GRAY )
#     diff = cv2.threshold ( diff, 20, 255, cv2.THRESH_BINARY )[1]
#
#     # 找到差分图像中的轮廓
#     contours, _ = cv2.findContours ( diff, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE )
#     print ( contours )
#
# # 释放视频对象和销毁窗口
# video.release ()
# cv2.destroyAllWindows ()

# from modules.ocr.paddle_ocr import Pdocr
# import cv2
#
# # 读入视频
# recognizer = Pdocr()
# video = cv2.VideoCapture ( "video.mp4" )
#
# # 设置变量存储前一帧图像
# prev_frame = None
#
# while True :
#     # 读取当前帧
#     ret, frame = video.read ()
#
#
#     # 如果到达视频末尾，退出循环
#     if not ret :
#         break
#
#     # 如果前一帧图像不存在，将当前帧设置为前一帧
#     if prev_frame is None :
#         prev_frame = frame
#         continue
#
#     # 计算当前帧和前一帧的差分图像
#     diff = cv2.absdiff ( prev_frame, frame )
#
#     # 使用图像处理技术识别差分图像中的文本
#     # 代码省略
#
#     # 找到差分图像中的区域
#     _, threshold = cv2.threshold ( diff, 25, 255, cv2.THRESH_BINARY )
#     threshold = cv2.cvtColor ( threshold, cv2.COLOR_BGR2GRAY )
#     contours, _ = cv2.findContours ( threshold, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE )
#
#     # 循环遍历所有轮廓
#     for contour in contours :
#         x, y, w, h = cv2.boundingRect ( contour )
#
#         # 如果轮廓的大小超过阈值，则显示该轮廓中的图像
#         if cv2.contourArea ( contour ) > 500 :
#             new_img = frame[y :y + h, x :x + w]
#             cv2.imshow ( "New Image", new_img )
#
#     ocr_res = recognizer.recognize_text(frame)
#     #一张图内有多个文本框，每个文本框包含其在图片内的坐标，文本框内文字，文字的置信度
#     for text_box in ocr_res:
#         box_loc = text_box[0]
#         box_text = text_box[1][0]
#         text_conf = text_box[1][1]
#         # if box_loc[0][0]>x and
#
#     # 将当前帧设置为前一帧
#     prev_frame = frame
#     time.sleep(1)
#
#
#     # 等待用户的输入
#     if cv2.waitKey ( 1 ) == ord ( "q" ) :
#         break

    # # 将前一帧图像设置为变暗
    # prev_frame = cv2.cvtColor ( prev_frame, cv2.COLOR_BGR2GRAY )
    # prev_frame = cv2.GaussianBlur ( prev_frame, (21, 21), 0 )
    #
    # # 循环遍历所有轮廓
    # for contour in contours :
    #     x, y, w, h = cv2.boundingRect ( contour )
    #
    #     # 如果轮廓的大小超过阈值，则显示该轮廓中的图像
    #     if cv2.contourArea ( contour ) > 500 :
    #         new_img = frame[y :y + h, x :x + w]
    #         prev_frame = cv2.cvtColor ( prev_frame, cv2.COLOR_GRAY2RGB )
    #         prev_frame[y :y + h, x :x + w] = new_img
    #
    # # 显示图像
    # cv2.imshow ( "frame", prev_frame )
    #
    # # 检查是否按下了键盘上的'q'键
    # if cv2.waitKey ( 1 ) & 0xFF == ord ( 'q' ) :
    #     break







#
# import sqlite3
#
#
# def query_db(table_name, query_values, output_fields) :
#     conn = sqlite3.connect ( '../CLR.db' )
#     c = conn.cursor ()
#
#     query = "SELECT " + ", ".join ( output_fields ) + " FROM " + table_name + " WHERE "
#     conditions = []
#     for key, value in query_values.items () :
#         conditions.append ( key + " LIKE '%" + value + "%'" )
#     query += " AND ".join ( conditions )
#
#     c.execute ( query )
#     result = c.fetchall ()
#     conn.close ()
#
#     return result
#
# frame_lst = []
# # result = query_db('pic_data', {'pic_text' : '流浪地球','pic_date' : '2023-01-26'},['pic_seq','pic_date'])
# result = [(3058, '2023-01-26'), (3059, '2023-01-26'), (3062, '2023-01-26'), (3063, '2023-01-26'), (3064, '2023-01-26'), (3065, '2023-01-26'), (3066, '2023-01-26'), (3067, '2023-01-26'), (3068, '2023-01-26'), (3069, '2023-01-26'), (3070, '2023-01-26'), (3071, '2023-01-26'), (3072, '2023-01-26'), (3073, '2023-01-26'), (3074, '2023-01-26'), (3075, '2023-01-26'), (3076, '2023-01-26'), (3077, '2023-01-26'), (3078, '2023-01-26'), (3079, '2023-01-26'), (3080, '2023-01-26'), (3081, '2023-01-26'), (3082, '2023-01-26'), (3083, '2023-01-26'), (3085, '2023-01-26'), (3737, '2023-01-26'), (3738, '2023-01-26'), (3739, '2023-01-26'), (3740, '2023-01-26'), (3843, '2023-01-26'), (3844, '2023-01-26'), (3845, '2023-01-26'), (3846, '2023-01-26'), (3847, '2023-01-26'), (3848, '2023-01-26'), (3849, '2023-01-26'), (3850, '2023-01-26'), (3851, '2023-01-26'), (3852, '2023-01-26'), (3853, '2023-01-26'), (3854, '2023-01-26'), (3855, '2023-01-26'), (3856, '2023-01-26'), (3857, '2023-01-26'), (3858, '2023-01-26'), (3859, '2023-01-26'), (3860, '2023-01-26'), (3861, '2023-01-26'), (3862, '2023-01-26'), (3863, '2023-01-26'), (3864, '2023-01-26'), (3865, '2023-01-26'), (3866, '2023-01-26'), (3867, '2023-01-26'), (3868, '2023-01-26'), (3869, '2023-01-26'), (3870, '2023-01-26'), (3871, '2023-01-26'), (3872, '2023-01-26'), (3873, '2023-01-26'), (3874, '2023-01-26'), (3875, '2023-01-26'), (3876, '2023-01-26'), (3877, '2023-01-26'), (3878, '2023-01-26'), (3879, '2023-01-26'), (3880, '2023-01-26'), (3881, '2023-01-26'), (3882, '2023-01-26'), (3883, '2023-01-26'), (3886, '2023-01-26'), (3887, '2023-01-26'), (3888, '2023-01-26'), (3889, '2023-01-26'), (3890, '2023-01-26'), (3891, '2023-01-26'), (3892, '2023-01-26'), (3893, '2023-01-26'), (3894, '2023-01-26'), (3895, '2023-01-26'), (3896, '2023-01-26'), (3897, '2023-01-26'), (3898, '2023-01-26'), (3899, '2023-01-26'), (3900, '2023-01-26'), (3901, '2023-01-26'), (3902, '2023-01-26'), (4152, '2023-01-26'), (4153, '2023-01-26'), (4978, '2023-01-26'), (4979, '2023-01-26'), (4980, '2023-01-26'), (5114, '2023-01-26'), (5115, '2023-01-26'), (5116, '2023-01-26'), (5117, '2023-01-26'), (5118, '2023-01-26'), (5119, '2023-01-26'), (5120, '2023-01-26'), (5163, '2023-01-26'), (6198, '2023-01-26'), (6199, '2023-01-26'), (6364, '2023-01-26'), (6365, '2023-01-26'), (6366, '2023-01-26'), (6368, '2023-01-26'), (7213, '2023-01-26'), (7214, '2023-01-26'), (7215, '2023-01-26'), (7347, '2023-01-26'), (7348, '2023-01-26'), (7349, '2023-01-26'), (7350, '2023-01-26'), (7350, '2023-01-26'), (7350, '2023-01-26'), (7350, '2023-01-26'), (7350, '2023-01-26'), (7351, '2023-01-26'), (7351, '2023-01-26'), (7351, '2023-01-26'), (7351, '2023-01-26'), (7351, '2023-01-26'), (7352, '2023-01-26'), (7352, '2023-01-26'), (7352, '2023-01-26'), (7352, '2023-01-26'), (7352, '2023-01-26'), (7353, '2023-01-26'), (7354, '2023-01-26'), (7354, '2023-01-26'), (7354, '2023-01-26'), (7355, '2023-01-26'), (7356, '2023-01-26'), (7357, '2023-01-26'), (7358, '2023-01-26'), (7530, '2023-01-26'), (7531, '2023-01-26'), (7531, '2023-01-26'), (7531, '2023-01-26'), (7531, '2023-01-26'), (7531, '2023-01-26'), (7532, '2023-01-26'), (7532, '2023-01-26'), (7532, '2023-01-26'), (7532, '2023-01-26'), (7532, '2023-01-26'), (7533, '2023-01-26'), (7533, '2023-01-26'), (7533, '2023-01-26'), (7533, '2023-01-26'), (7533, '2023-01-26'), (7534, '2023-01-26'), (7534, '2023-01-26'), (7534, '2023-01-26'), (7534, '2023-01-26'), (7534, '2023-01-26'), (7535, '2023-01-26'), (7535, '2023-01-26'), (7535, '2023-01-26'), (7535, '2023-01-26'), (7535, '2023-01-26'), (7536, '2023-01-26'), (7536, '2023-01-26'), (7536, '2023-01-26'), (7536, '2023-01-26'), (7536, '2023-01-26'), (7537, '2023-01-26'), (7537, '2023-01-26'), (7537, '2023-01-26'), (7537, '2023-01-26'), (7537, '2023-01-26'), (7538, '2023-01-26'), (7538, '2023-01-26'), (7538, '2023-01-26'), (7538, '2023-01-26'), (7538, '2023-01-26'), (7539, '2023-01-26'), (7539, '2023-01-26'), (7539, '2023-01-26'), (7539, '2023-01-26'), (7539, '2023-01-26'), (7540, '2023-01-26'), (7540, '2023-01-26'), (7540, '2023-01-26'), (7540, '2023-01-26'), (7540, '2023-01-26'), (7541, '2023-01-26'), (7541, '2023-01-26'), (7541, '2023-01-26'), (7541, '2023-01-26'), (7541, '2023-01-26'), (7542, '2023-01-26'), (7542, '2023-01-26'), (7542, '2023-01-26'), (7542, '2023-01-26'), (7542, '2023-01-26'), (7543, '2023-01-26'), (7543, '2023-01-26'), (7543, '2023-01-26'), (7543, '2023-01-26'), (7543, '2023-01-26'), (7544, '2023-01-26'), (7544, '2023-01-26'), (7544, '2023-01-26'), (7544, '2023-01-26'), (7544, '2023-01-26'), (7545, '2023-01-26'), (7545, '2023-01-26'), (7545, '2023-01-26'), (7545, '2023-01-26'), (7545, '2023-01-26'), (7546, '2023-01-26'), (7546, '2023-01-26'), (7546, '2023-01-26'), (7546, '2023-01-26'), (7546, '2023-01-26'), (7547, '2023-01-26'), (7547, '2023-01-26'), (7547, '2023-01-26'), (7547, '2023-01-26'), (7547, '2023-01-26'), (7548, '2023-01-26'), (7548, '2023-01-26'), (7548, '2023-01-26'), (7548, '2023-01-26'), (7548, '2023-01-26'), (7549, '2023-01-26'), (7549, '2023-01-26'), (7549, '2023-01-26'), (7549, '2023-01-26'), (7549, '2023-01-26'), (7550, '2023-01-26'), (7550, '2023-01-26'), (7550, '2023-01-26'), (7550, '2023-01-26'), (7550, '2023-01-26'), (7551, '2023-01-26'), (7551, '2023-01-26'), (7551, '2023-01-26'), (7551, '2023-01-26'), (7551, '2023-01-26'), (7552, '2023-01-26'), (7552, '2023-01-26'), (7552, '2023-01-26'), (7552, '2023-01-26'), (7552, '2023-01-26'), (7553, '2023-01-26'), (7553, '2023-01-26'), (7553, '2023-01-26'), (7553, '2023-01-26'), (7553, '2023-01-26'), (7554, '2023-01-26'), (7554, '2023-01-26'), (7554, '2023-01-26'), (7554, '2023-01-26'), (7554, '2023-01-26'), (7555, '2023-01-26'), (7555, '2023-01-26'), (7555, '2023-01-26'), (7555, '2023-01-26'), (7555, '2023-01-26'), (7556, '2023-01-26'), (7556, '2023-01-26'), (7556, '2023-01-26'), (7556, '2023-01-26'), (7556, '2023-01-26'), (7557, '2023-01-26'), (7557, '2023-01-26'), (7557, '2023-01-26'), (7557, '2023-01-26'), (7557, '2023-01-26'), (7558, '2023-01-26'), (7559, '2023-01-26'), (7560, '2023-01-26'), (7584, '2023-01-26'), (7585, '2023-01-26'), (7586, '2023-01-26'), (7586, '2023-01-26'), (7587, '2023-01-26'), (7587, '2023-01-26'), (7609, '2023-01-26'), (7609, '2023-01-26'), (7609, '2023-01-26'), (7609, '2023-01-26'), (7609, '2023-01-26'), (7610, '2023-01-26'), (7610, '2023-01-26'), (7610, '2023-01-26'), (7610, '2023-01-26'), (7610, '2023-01-26'), (7611, '2023-01-26'), (7615, '2023-01-26'), (7615, '2023-01-26'), (7615, '2023-01-26'), (7615, '2023-01-26'), (7615, '2023-01-26'), (7616, '2023-01-26'), (7616, '2023-01-26'), (7616, '2023-01-26'), (7616, '2023-01-26'), (7616, '2023-01-26'), (7617, '2023-01-26'), (7620, '2023-01-26'), (7620, '2023-01-26'), (7620, '2023-01-26'), (7620, '2023-01-26'), (7620, '2023-01-26'), (7621, '2023-01-26'), (7621, '2023-01-26'), (7621, '2023-01-26'), (7621, '2023-01-26'), (7621, '2023-01-26'), (7622, '2023-01-26'), (7622, '2023-01-26'), (7622, '2023-01-26'), (7622, '2023-01-26'), (7622, '2023-01-26'), (7623, '2023-01-26'), (7623, '2023-01-26'), (7623, '2023-01-26'), (7623, '2023-01-26'), (7623, '2023-01-26'), (7624, '2023-01-26'), (7624, '2023-01-26'), (7624, '2023-01-26'), (7624, '2023-01-26'), (7624, '2023-01-26'), (7625, '2023-01-26'), (7625, '2023-01-26'), (7625, '2023-01-26'), (7625, '2023-01-26'), (7625, '2023-01-26'), (7626, '2023-01-26'), (7626, '2023-01-26'), (7626, '2023-01-26'), (7626, '2023-01-26'), (7626, '2023-01-26'), (7627, '2023-01-26'), (7627, '2023-01-26'), (7627, '2023-01-26'), (7627, '2023-01-26'), (7627, '2023-01-26'), (7628, '2023-01-26'), (7628, '2023-01-26'), (7628, '2023-01-26'), (7628, '2023-01-26'), (7628, '2023-01-26'), (7629, '2023-01-26'), (7629, '2023-01-26'), (7629, '2023-01-26'), (7629, '2023-01-26'), (7629, '2023-01-26'), (7630, '2023-01-26'), (7630, '2023-01-26'), (7630, '2023-01-26'), (7630, '2023-01-26'), (7630, '2023-01-26'), (7631, '2023-01-26'), (7631, '2023-01-26'), (7631, '2023-01-26'), (7631, '2023-01-26'), (7631, '2023-01-26'), (7632, '2023-01-26'), (7632, '2023-01-26'), (7632, '2023-01-26'), (7632, '2023-01-26'), (7632, '2023-01-26'), (7633, '2023-01-26'), (7633, '2023-01-26'), (7633, '2023-01-26'), (7633, '2023-01-26'), (7633, '2023-01-26'), (7634, '2023-01-26'), (7634, '2023-01-26'), (7634, '2023-01-26'), (7634, '2023-01-26'), (7634, '2023-01-26'), (7635, '2023-01-26'), (7635, '2023-01-26'), (7635, '2023-01-26'), (7635, '2023-01-26'), (7635, '2023-01-26'), (7636, '2023-01-26'), (7636, '2023-01-26'), (7636, '2023-01-26'), (7636, '2023-01-26'), (7636, '2023-01-26'), (7637, '2023-01-26'), (7637, '2023-01-26'), (7637, '2023-01-26'), (7637, '2023-01-26'), (7637, '2023-01-26'), (7638, '2023-01-26'), (7638, '2023-01-26'), (7638, '2023-01-26'), (7638, '2023-01-26'), (7638, '2023-01-26'), (7639, '2023-01-26'), (7639, '2023-01-26'), (7639, '2023-01-26'), (7639, '2023-01-26'), (7639, '2023-01-26'), (7640, '2023-01-26'), (7640, '2023-01-26'), (7640, '2023-01-26'), (7640, '2023-01-26'), (7640, '2023-01-26'), (7641, '2023-01-26'), (7641, '2023-01-26'), (7641, '2023-01-26'), (7641, '2023-01-26'), (7641, '2023-01-26'), (7642, '2023-01-26'), (7642, '2023-01-26'), (7642, '2023-01-26'), (7642, '2023-01-26'), (7642, '2023-01-26'), (7643, '2023-01-26'), (7643, '2023-01-26'), (7643, '2023-01-26'), (7643, '2023-01-26'), (7643, '2023-01-26'), (7644, '2023-01-26'), (7644, '2023-01-26'), (7644, '2023-01-26'), (7644, '2023-01-26'), (7644, '2023-01-26'), (7645, '2023-01-26'), (7645, '2023-01-26'), (7645, '2023-01-26'), (7645, '2023-01-26'), (7645, '2023-01-26'), (7646, '2023-01-26'), (7646, '2023-01-26'), (7646, '2023-01-26'), (7646, '2023-01-26'), (7646, '2023-01-26'), (7647, '2023-01-26'), (7647, '2023-01-26'), (7647, '2023-01-26'), (7647, '2023-01-26'), (7647, '2023-01-26'), (7648, '2023-01-26'), (7648, '2023-01-26'), (7648, '2023-01-26'), (7648, '2023-01-26'), (7648, '2023-01-26'), (7649, '2023-01-26'), (7649, '2023-01-26'), (7649, '2023-01-26'), (7649, '2023-01-26'), (7649, '2023-01-26'), (7650, '2023-01-26'), (7650, '2023-01-26'), (7650, '2023-01-26'), (7650, '2023-01-26'), (7650, '2023-01-26'), (7651, '2023-01-26'), (7651, '2023-01-26'), (7651, '2023-01-26'), (7651, '2023-01-26'), (7651, '2023-01-26'), (7652, '2023-01-26'), (7652, '2023-01-26'), (7652, '2023-01-26'), (7652, '2023-01-26'), (7652, '2023-01-26'), (7653, '2023-01-26'), (7653, '2023-01-26'), (7653, '2023-01-26'), (7653, '2023-01-26'), (7653, '2023-01-26'), (7844, '2023-01-26'), (8009, '2023-01-26'), (8010, '2023-01-26'), (8036, '2023-01-26'), (8037, '2023-01-26'), (8038, '2023-01-26'), (8039, '2023-01-26'), (8171, '2023-01-26'), (8172, '2023-01-26'), (8172, '2023-01-26'), (8173, '2023-01-26'), (8174, '2023-01-26'), (8174, '2023-01-26'), (8175, '2023-01-26'), (8175, '2023-01-26'), (8176, '2023-01-26'), (8176, '2023-01-26'), (8177, '2023-01-26'), (8177, '2023-01-26'), (8178, '2023-01-26'), (8179, '2023-01-26'), (8179, '2023-01-26'), (8180, '2023-01-26'), (8191, '2023-01-26'), (8192, '2023-01-26'), (8235, '2023-01-26'), (8238, '2023-01-26'), (8239, '2023-01-26'), (8242, '2023-01-26'), (8243, '2023-01-26'), (8244, '2023-01-26'), (8244, '2023-01-26'), (8246, '2023-01-26'), (8246, '2023-01-26'), (8247, '2023-01-26'), (8248, '2023-01-26'), (8248, '2023-01-26'), (8249, '2023-01-26'), (8250, '2023-01-26'), (8251, '2023-01-26'), (8252, '2023-01-26'), (8254, '2023-01-26'), (8255, '2023-01-26'), (8256, '2023-01-26'), (8257, '2023-01-26'), (8258, '2023-01-26'), (8259, '2023-01-26'), (8260, '2023-01-26'), (8260, '2023-01-26'), (8261, '2023-01-26'), (8261, '2023-01-26'), (8262, '2023-01-26'), (8262, '2023-01-26'), (8263, '2023-01-26'), (8263, '2023-01-26'), (8264, '2023-01-26'), (8264, '2023-01-26'), (8265, '2023-01-26'), (8266, '2023-01-26'), (8267, '2023-01-26'), (8268, '2023-01-26'), (8274, '2023-01-26'), (8275, '2023-01-26'), (8276, '2023-01-26'), (8276, '2023-01-26'), (8276, '2023-01-26'), (8277, '2023-01-26'), (8277, '2023-01-26'), (8277, '2023-01-26'), (8278, '2023-01-26'), (8278, '2023-01-26'), (8278, '2023-01-26'), (8279, '2023-01-26'), (8279, '2023-01-26'), (8279, '2023-01-26'), (8280, '2023-01-26'), (8295, '2023-01-26'), (8296, '2023-01-26'), (8301, '2023-01-26'), (8302, '2023-01-26'), (10975, '2023-01-26'), (10976, '2023-01-26'), (10977, '2023-01-26'), (10978, '2023-01-26'), (11137, '2023-01-26'), (11138, '2023-01-26'), (11139, '2023-01-26'), (11140, '2023-01-26'), (11228, '2023-01-26'), (11229, '2023-01-26'), (11230, '2023-01-26'), (11231, '2023-01-26'), (11321, '2023-01-26'), (11322, '2023-01-26'), (11323, '2023-01-26'), (11324, '2023-01-26'), (11325, '2023-01-26'), (11326, '2023-01-26'), (11327, '2023-01-26'), (11328, '2023-01-26'), (11329, '2023-01-26'), (11330, '2023-01-26'), (12080, '2023-01-26'), (12081, '2023-01-26'), (12082, '2023-01-26'), (12083, '2023-01-26'), (12084, '2023-01-26'), (12085, '2023-01-26'), (12086, '2023-01-26'), (12090, '2023-01-26'), (12628, '2023-01-26'), (12629, '2023-01-26'), (12630, '2023-01-26')]
# for i in result:
#     frame_lst.append(i[0])
# play_video(r"D:\ManicTime_Screenshots\2023-01-26_1920x1080.mp4",frame_lst)

# from pynput import keyboard
#
# log_file = "keyboard_log.txt"
#
# def on_press(key):
#     try:
#         with open(log_file, "a") as f:
#             f.write(f"Key pressed: {key}\n")
#     except:
#         pass
#
# def on_release(key):
#     try:
#         with open(log_file, "a") as f:
#             f.write(f"Key released: {key}\n")
#     except:
#         pass
#
# with keyboard.Listener(on_press=on_press, on_release=on_release) as listener:
#     listener.join()

# def fibonacci(number):
#     a, b = 0, 1
#     while a < number:
#         print (a)
#         a, b = b, a + b
#     return a
#
# print( fibonacci(100))

# a, b = 0, 1
# while a < 100:
#     print(a)
#     a, b = b, a + b

# import os
# path1 = r'"D:\ManicTime_Screenshots\2023-02-03\2023-02-03_00-00-03_08-00_1920_1080_209954_0.jpg"'
# a = os.path.basename(os.path.dirname(path1))
# print(a[:10])
# print(a[-9 :])


# import json
# from datetime import datetime
#
# def a():
#     # 实现方法 a 的代码，根据情况修改
#     date = datetime.now().strftime("%Y-%m-%d")
#     resolution = "1920x1080"
#     return date, resolution
#
# def update_seq_log(date, resolution):
#     s = 0
#     try:
#         # 打开 seq_log.json 文件
#         with open('seq_log.json', 'r') as f:
#             seq_log = json.load(f)
#     except FileNotFoundError:
#         # 如果文件不存在，则新建一个空的 seq_log
#         seq_log = []
#
#     # 遍历 seq_log，查找符合 date 和 resolution 的行
#     found = False
#     for item in seq_log:
#         if item['date'] == date and item['resolution'] == resolution:
#             # 如果找到了，则将 s 赋值为该行的 seq，并将 seq 增加 1
#             s = item['seq']
#             item['seq'] += 1
#             found = True
#             break
#
#     if not found:
#         # 如果没找到，则添加一行，seq 设为 1
#         s = 1
#         seq_log.append({'date': date, 'resolution': resolution, 'seq': s})
#
#
#     # 将 seq_log 写入文件
#     with open('seq_log.json', 'w') as f:
#         json.dump(seq_log, f, indent=4)
#
#     return s
#
#
# if __name__ == '__main__':
#     # 调用方法 a 获取 date 和 resolution
#     date, resolution = a ()
#
#     # 更新 seq_log-
#     update_seq_log ( date, resolution )

# import clr
# clr.AddReference("PresentationCore")
# clr.AddReference("PresentationFramework")
# from System.Windows import Application, Window
#
# class MyWindow(Window):
#     def __init__(self):
#         self.Title = "Hello, WPF from Python!"
#         self.Width = 250
#         self.Height = 100
#
# if __name__ == '__main__':
#     app = Application()
#     window = MyWindow()
#     app.Run(window)

# import flet as ft
#
# def main(page: ft.Page):
#     page.title = "Flet counter example"
#     page.vertical_alignment = ft.MainAxisAlignment.CENTER
#
#     txt_number = ft.TextField(value="0", text_align=ft.TextAlign.RIGHT, width=100)
#
#     def minus_click(e):
#         txt_number.value = str(int(txt_number.value) - 1)
#         page.update()
#
#     def plus_click(e):
#         txt_number.value = str(int(txt_number.value) + 1)
#         page.update()
#
#     page.add(
#         ft.Row(
#             [
#                 ft.IconButton(ft.icons.REMOVE, on_click=minus_click),
#                 txt_number,
#                 ft.IconButton(ft.icons.ADD, on_click=plus_click),
#             ],
#             alignment=ft.MainAxisAlignment.CENTER,
#         )
#     )
#
# ft.app(target=main)


# dic = {'13917591234': ['999元', '5G','189分钟'],'13917591235': ['555元', '4G','100分钟']}
# num = input('请输入查询的手机号码：')
# print('{:-^20}'.format('10086查询功能'))
# a = input('输入1，查询余额\n输入2，查询流量\n输入3，查询剩余通话\n输入#，退出或者返回上一级')
# if num == '13917591234':
#     for i in dic['13917591234']:
#         print(i)
#         if a == 1:
#             print('余额为：',i[0])
#         elif a == 2:
#             print('流量为：',i[1])
#         elif a == 3:
#             print('剩余通话为：', i[2])
#         elif a == '#':
#             break
#         else:
#             break
# if num == '13917591235':
#     for j in dic['13917591235']:
#         if a == 1:
#             print(j[0])
#         elif a == 2:
#             print(j[1])
#         elif a == 3:
#             print(j[2])
#         elif a == '#':
#             break
#         else:
#             break
